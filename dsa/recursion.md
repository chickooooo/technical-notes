# Recursion

<br>
<br>
<br>
<br>
<br>

## Patterns

- Time complexity of **Include / not include `i`** is: `O(2^n)`.

<br>
<br>
<br>
<br>
<br>

## Problems

<br>
<br>
<br>

### Combination sum

- Problem: Find all unique combinations of numbers from a list that sum up to a given target, where each number can be used multiple times.
- Link: https://leetcode.com/problems/combination-sum/

---

- **Algorithm**: `i` iterates over array
- Sort the given array first.
- Start with `index=0` and `total=0`.
- Iterate over the array starting from `i=index` till `i=n-1`.
- While iterating add the `ith` element in the `temp` array and increase the `total`.
- Keep doing so recursively until `total` is equal to or greater than the target.
    - If equal, make copy of `temp` and add it to `output` array. Return `false`.
    - If greater, return `false`. `false` indicates that the upper loop should not continue.
- After each recursive call, remove the last element from `temp` array.
- Before the end of recursive function, return `true`.

---

- Returning `true` & `false` helps with early stopping and avoid unnecessary recursion calls.
- Early stopping can only be implemented if the array is sorted.

<br>
<br>
<br>

### Combination sum with duplicates

- Problem: Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.
- Link: https://leetcode.com/problems/combination-sum-ii/

---

- **Algorithm**: `i` iterates over array
- Sort the given array first.
- Start with `index=-1` and `total=0`.
- Iterate over the array starting from `i=index+1` till `i=n-1`.
- While iterating add the `ith` element in the `temp` array and increase the `total`.
- Keep doing so recursively until `total` is equal to or greater than the target.
    - If equal, make copy of `temp` and add it to `output` array. Return `false`.
    - If greater, return `false`. `false` indicates that the upper loop should not continue.
- After each recursive call, remove the last element from `temp` array.
- Before the end of recursive function, return `true`.

---

- Duplicate handling:
    - If the current element is same as the last popped element, skip it.
    - All the combinations that will be generated by the current element are already covered by last popped element.

---

- Early stopping:
    - Returning `true` & `false` helps with early stopping and avoid unnecessary recursion calls.
    - Early stopping can only be implemented if the array is sorted.

<br>
<br>
<br>

### All possible subsets

- Problem: Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
- Link: https://leetcode.com/problems/subsets/

---

- **Algorithm**: Include / not include `i`
- Create two empty arrays to hold the output (`output`) and elements during recursion (`temp`).
- Start with `i=0`. At each step, we can either include `ith` element or exclude it.
- First add `ith` element to temp array and go to `(i+1)th` step.
- After `(i+1)th` step has completed, remove the last element from the array (this will be the `ith` element).
- Then again go to `(i+1)th` step.
- Once we reach `(i=n)th` step, make copy of `temp` and add it to the `output`.
- At last, return the `output`.

<br>
<br>
<br>

### All possible subsets with duplicates

- Problem: Given an integer array nums that may contain duplicates, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order.
- Link: https://leetcode.com/problems/subsets-ii/

---

- **Algorithm**: Include / not include `i`
- Sort the given array first.
- Create two empty arrays to hold the output (`output`) and elements during recursion (`temp`).
- Start with `i=0`. At each step, we can either include `ith` element or exclude it.
- First add `ith` element to temp array and go to `(i+1)th` step.
- After `(i+1)th` step has completed, remove the last element from the array (this will be the `ith` element).
- Then again go to `(i+1)th` step.
- Once we reach `(i=n)th` step, make copy of `temp` and add it to the `output`.
- At last, return the `output`.

---

- Duplicate handling:
    - If the `ith` element is same as the last popped element, skip adding it.
    - All the subsets that will be generated by the `ith` element are already covered by last popped element.

<br>
<br>
<br>

### Combination sum III

- Problem: Find all unique combinations of k distinct numbers from 1 to 9 that add up to n. Each number can be used at most once, and combinations can be in any order.
- Link: https://leetcode.com/problems/combination-sum-iii/

---

- **Algorithm**: `i` iterates over array
- Similar approach as combination sum 1 & 2.
- Use early stopping to avoid unnecessary recursion calls.

### Letter combinations of a phone number

- Problem: Given a string of digits 2-9, return all possible letter combinations the digits could represent using a telephone keypad mapping. Return in any order.
- Link: https://leetcode.com/problems/letter-combinations-of-a-phone-number/

---

- **Algorithm**: `i` iterates over array
- Standard algorithm. No special handling needed.

<br>
<br>
<br>

### Word search

- Problem: Given an m Ã— n character grid and a word, determine if the word can be formed by sequentially adjacent (horizontal or vertical) cells without reusing any cell.
- Link: https://leetcode.com/problems/word-search/

---

- **Algorithm**: Backtracking on grid
- Iterate over the grid and the word simultaneously.
- If current grid element matches with current letter of the word, then try to match the next letter of the word in adjacent grid cells.
- Keep on doing this until complete word is matched.

<br>
<br>
<br>

### 

<br>
<br>
<br>
