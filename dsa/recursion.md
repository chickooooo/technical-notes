# Recursion

<br>
<br>
<br>
<br>
<br>

## Patterns

- Time complexity of **Include / not include `i`** is: `O(2^n)`.

<br>
<br>
<br>
<br>
<br>

## Problems

<br>
<br>
<br>

### Combination sum

- Problem: Find all unique combinations of numbers from a list that sum up to a given target, where each number can be used multiple times.
- Link: https://leetcode.com/problems/combination-sum/

---

- **Algorithm**: `i` iterates over array
- Sort the given array first.
- Start with `index=0` and `total=0`.
- Iterate over the array starting from `i=index` till `i=n-1`.
- While iterating add the `ith` element in the `temp` array and increase the `total`.
- Keep doing so recursively until `total` is equal to or greater than the target.
    - If equal, make copy of `temp` and add it to `output` array. Return `false`.
    - If greater, return `false`. `false` indicates that the upper loop should not continue.
- After each recursive call, remove the last element from `temp` array.
- Before the end of recursive function, return `true`.

---

- Returning `true` & `false` helps with early stopping and avoid unnecessary recursion calls.
- Early stopping can only be implemented if the array is sorted.

<br>
<br>
<br>

### Combination sum II

- Problem: Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.
- Link: https://leetcode.com/problems/combination-sum-ii/

---

- **Algorithm**: `i` iterates over array
- Sort the given array first.
- Start with `index=-1` and `total=0`.
- Iterate over the array starting from `i=index+1` till `i=n-1`.
- While iterating add the `ith` element in the `temp` array and increase the `total`.
- Keep doing so recursively until `total` is equal to or greater than the target.
    - If equal, make copy of `temp` and add it to `output` array. Return `false`.
    - If greater, return `false`. `false` indicates that the upper loop should not continue.
- After each recursive call, remove the last element from `temp` array.
- Before the end of recursive function, return `true`.

---

- Duplicate handling:
    - If the current element is same as the last popped element, skip it.
    - All the combinations that will be generated by the current element are already covered by last popped element.

---

- Early stopping:
    - Returning `true` & `false` helps with early stopping and avoid unnecessary recursion calls.
    - Early stopping can only be implemented if the array is sorted.

<br>
<br>
<br>

### All possible subsets

- Problem: Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
- Link: https://leetcode.com/problems/subsets/

---

- **Algorithm**: Include / not include `i`
- Create two empty arrays to hold the output (`output`) and elements during recursion (`temp`).
- Start with `i=0`. At each step, we can either include `ith` element or exclude it.
- First add `ith` element to temp array and go to `(i+1)th` step.
- After `(i+1)th` step has completed, remove the last element from the array (this will be the `ith` element).
- Then again go to `(i+1)th` step.
- Once we reach `(i=n)th` step, make copy of `temp` and add it to the `output`.
- At last, return the `output`.

<br>
<br>
<br>

### 

<br>
<br>
<br>
